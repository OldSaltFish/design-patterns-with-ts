## 目的/作用

1. **资源的集中管理**，将某个资源交给一个统一的对象进行管理，比如数据库连接池、线程池或者日志记录器
2. **全局共享**，应用的任何部分都可以方便地访问这个唯一实例
3. **状态一致性**，由于只有一个实例，不需要考虑状态不一致的问题。



## 注意事项

1. **反射攻击**：外部可以通过反射API强行调用私有的构造函数创建新的实例，破坏单例。可以通过在构造函数中添加校验逻辑来防御。  
> 这一点在js中不需要考虑，因为私有属性和方法是通过符号（Symbol）实现的

2. **线程安全**：在多线程环境下，必须确保单例的创建过程是线程安全的。常见的实现方式有双重检查锁定（Double-Checked Locking）、静态内部类等，以避免多线程同时创建实例。  
> 这一点在js中不需要考虑，因为js是单线程的


## 实现
### 懒汉式
懒汉式（Lazy Initialization），在第一次调用时才创建实例，即延迟加载。这种方式在多线程环境下可能存在问题，因为创建实例的过程不是原子操作，可能会导致多个线程同时创建实例。  

### 饿汉式
饿汉式（Eager Initialization），在类加载时即创建实例，即在类加载时完成实例的初始化。这种方式在多线程环境下是线程安全的，因为创建实例的过程是原子操作。 

> 在大多数情况下，ts的单例模式都是饿汉式的，因为开销很低。  
> 而且用起来也很简单，引入后直接getInstance就行了，或者直接把实例导出。


### 其他
这不符合常规的单例模式，但是实现了单例，我认为这是js中实现饿汉式的变种（因为饿汉式也不需要自己来创建实例）。  
> 既然每次使用这个单例时都要getInstance，不如直接导出这个实例，写起来也简单，用起来也简单。  

直接导出单个实例。  